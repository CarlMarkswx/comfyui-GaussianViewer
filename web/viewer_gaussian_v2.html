<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeomPack Gaussian Splat Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a1a;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #viewerContainer {
            position: relative;
            flex: 1;
            min-height: 0;
        }

        #canvasWrapper {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #ff6b6b;
            padding: 20px;
            max-width: 80%;
        }

        .error.hidden {
            display: none;
        }

        #controlsBar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            background: #252525;
            padding: 8px 12px;
            border-top: 1px solid #333;
            flex-shrink: 0;
        }

        #controlsBar button {
            background: #444;
            border: none;
            color: #fff;
            padding: 4px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }

        #controlsBar button:hover {
            background: #555;
        }

        .scale-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .scale-control span {
            color: #888;
            font-size: 11px;
        }

        .scale-control input[type="number"] {
            width: 60px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            font-size: 11px;
            padding: 4px 6px;
            border-radius: 3px;
        }

        .info-panel {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 4px;
            color: #aaa;
            font-size: 11px;
            font-family: monospace;
            z-index: 50;
        }

        .info-panel.hidden {
            display: none;
        }

        #cropFrame {
            position: absolute;
            border: 2px solid rgba(255, 80, 80, 0.85);
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            z-index: 40;
        }

        .ratio-panel {
            position: absolute;
            left: 8px;
            bottom: 8px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 8px;
            display: grid;
            grid-template-columns: auto;
            gap: 6px;
            z-index: 45;
        }

        .ratio-panel .label {
            color: #cfcfcf;
            font-size: 11px;
        }

        .ratio-select {
            background: #222;
            color: #ddd;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 11px;
            min-width: 110px;
        }
    </style>
</head>
<body>
    <div id="viewerContainer">
        <div id="canvasWrapper">
            <canvas id="canvas"></canvas>
            <div id="cropFrame" aria-hidden="true"></div>
        </div>

        <div id="error" class="error hidden"></div>

        <div id="infoPanel" class="info-panel hidden">
            <div id="infoContent"></div>
        </div>

        <div id="ratioPanel" class="ratio-panel" aria-label="Aspect ratio presets">
            <div class="label">Image Ratio</div>
            <select id="ratioSelect" class="ratio-select">
                <option value="source">Source</option>
                <option value="1:1">1:1</option>
                <option value="1:2">1:2</option>
                <option value="4:3">4:3</option>
                <option value="3:4">3:4</option>
                <option value="16:9">16:9</option>
                <option value="9:16">9:16</option>
            </select>
        </div>
    </div>

    <div id="controlsBar">
        <div class="scale-control">
            <span>Scale:</span>
            <input type="number" id="gaussianScaleValue" min="0.01" max="100" step="0.1" value="1.0" title="Gaussian scale multiplier">
        </div>
        <button id="resetCamera" title="Reset camera view">Reset View</button>
        <div class="scale-control">
            <span>Focal:</span>
            <input type="range" id="focalScale" min="0.2" max="3.0" step="0.01" value="1.0" title="Focal length scale">
            <input type="number" id="focalScaleValue" min="0.2" max="3.0" step="0.01" value="1.0" title="Focal length scale value">
        </div>
        <button id="setCamera" title="Save current camera for render">Set Camera</button>
    </div>

    <!-- Load bundled gsplat.js -->
    <script src="./js/gsplat-bundle.js"></script>

    <script type="module">
        // Use the globally exported GSPLAT
        const SPLAT = window.GSPLAT;

        // DOM elements
        const canvas = document.getElementById('canvas');
        const errorEl = document.getElementById('error');
        const infoPanel = document.getElementById('infoPanel');
        const infoContent = document.getElementById('infoContent');
        const cropFrame = document.getElementById('cropFrame');

        // gsplat.js components
        let scene = null;
        let camera = null;
        let renderer = null;
        let controls = null;
        let animationId = null;
        let currentSplat = null;
        let originalScales = null;  // Store original scales for dynamic adjustment
        let baseFocalLength = null;
        let baseFocalY = null;
        let nativeAspect = null;
        let nativeImageWidth = null;
        let nativeImageHeight = null;

        // Default focal length
        const DEFAULT_FOCAL_LENGTH = 30;

        // Initialize the viewer
        function initViewer() {
            console.log('[GaussianViewer] ===== INITIALIZING VIEWER =====');
            try {
                console.log('[GaussianViewer] Creating scene...');
                scene = new SPLAT.Scene();
                
                console.log('[GaussianViewer] Creating camera...');
                camera = new SPLAT.Camera();
                
                console.log('[GaussianViewer] Creating renderer...');
                renderer = new SPLAT.WebGLRenderer(canvas);
                
                console.log('[GaussianViewer] Creating orbit controls...');
                controls = new SPLAT.OrbitControls(camera, canvas);

                // Set default focal length
                console.log('[GaussianViewer] Setting default focal length...');
                console.log(`[GaussianViewer] DEFAULT_FOCAL_LENGTH = ${DEFAULT_FOCAL_LENGTH}`);
                camera.data.fx = DEFAULT_FOCAL_LENGTH;
                camera.data.fy = DEFAULT_FOCAL_LENGTH;
                baseFocalLength = camera.data.fx;
                baseFocalY = camera.data.fy;
                console.log(`[GaussianViewer] Applied focal length: fx=${camera.data.fx}, fy=${camera.data.fy}`);
                console.log(`[GaussianViewer] Base focal length stored: baseFx=${baseFocalLength}, baseFy=${baseFocalY}`);
                
                // Calculate and log FOV for default settings
                const canvasHeight = canvas.clientHeight || 512;
                const defaultFovY = 2 * Math.atan(canvasHeight / (2 * camera.data.fy));
                const defaultFovYDeg = defaultFovY * 180 / Math.PI;
                console.log(`[GaussianViewer] Default FOV Y (with canvas height ${canvasHeight}): ${defaultFovYDeg.toFixed(2)} degrees`);

                // Handle resize
                const resize = () => {
                    // Only resize renderer if resolution is NOT locked
                    // If locked, the canvas resolution stays fixed (e.g. at 2K),
                    // and CSS handles the visual fitting to container.
                    if (!isResolutionLocked) {
                        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                        nativeAspect = (canvas.clientWidth || 1) / (canvas.clientHeight || 1);
                    }
                    scheduleFrameLayoutUpdate();
                };
                window.addEventListener('resize', resize);
                resize();
                scheduleFrameLayoutUpdate();

                // Start render loop
                const frame = () => {
                    controls.update();
                    renderer.render(scene, camera);
                    animationId = requestAnimationFrame(frame);
                };
                frame();

                console.log('[GaussianViewer] Initialized successfully');
            } catch (err) {
                console.error('[GaussianViewer] Init error:', err);
                showError('Failed to initialize WebGL viewer: ' + err.message);
            }
        }

        // Show error
        function showError(message) {
            errorEl.textContent = message;
            errorEl.classList.remove('hidden');
        }

        // Store initial camera params for reset
        let initialCameraData = null;
        let lastMeshSignature = null;

        // Resolution lock state
        let isResolutionLocked = false;

        // Scale compensation: when focal length is scaled down for canvas size,
        // gaussian scales need to be multiplied by this factor to maintain correct screen-space size
        let gaussianScaleCompensation = 1.0;
        let outputSettings = {
            resolution: 1024,
            aspectRatio: "source"
        };

        // Resume the animation loop (used after pausing for screenshot/clipboard)
        function resumeAnimationLoop() {
            const frame = () => {
                controls.update();
                renderer.render(scene, camera);
                animationId = requestAnimationFrame(frame);
            };
            frame();
        }

        // Set camera from extrinsics and intrinsics
        // extrinsics: 4x4 matrix (identity for SHARP = camera at origin looking down +Z)
        // intrinsics: 3x3 matrix [[fx, 0, cx], [0, fy, cy], [0, 0, 1]]
        // splat: the loaded Gaussian splat object (optional, used for bounds)
        function setCameraFromExtrinsics(extrinsics, intrinsics, splat) {
            if (!camera || !controls) return;

            console.log('[GaussianViewer] Setting camera from extrinsics/intrinsics');
            console.log('[GaussianViewer] Extrinsics:', JSON.stringify(extrinsics));
            console.log('[GaussianViewer] Intrinsics:', JSON.stringify(intrinsics));

            // Parse extrinsics to get camera position
            // For a 4x4 extrinsics matrix [R|t], camera position in world space is -R^T * t
            // But for identity matrix, camera is simply at origin
            let camPosX = 0, camPosY = 0, camPosZ = 0;

            if (extrinsics && Array.isArray(extrinsics) && extrinsics.length === 4) {
                // Extract rotation and translation from 4x4 extrinsics
                const R = [
                    [extrinsics[0][0], extrinsics[0][1], extrinsics[0][2]],
                    [extrinsics[1][0], extrinsics[1][1], extrinsics[1][2]],
                    [extrinsics[2][0], extrinsics[2][1], extrinsics[2][2]]
                ];
                const t = [extrinsics[0][3], extrinsics[1][3], extrinsics[2][3]];

                // Camera position = -R^T * t
                camPosX = -(R[0][0] * t[0] + R[1][0] * t[1] + R[2][0] * t[2]);
                camPosY = -(R[0][1] * t[0] + R[1][1] * t[1] + R[2][1] * t[2]);
                camPosZ = -(R[0][2] * t[0] + R[1][2] * t[1] + R[2][2] * t[2]);

                console.log('[GaussianViewer] Computed camera position from extrinsics:', camPosX, camPosY, camPosZ);
            }

            // Calculate FOV and set camera focal length from intrinsics
            // intrinsics[0][0] = fx (focal length in pixels)
            // intrinsics[1][1] = fy (focal length in pixels)
            // intrinsics[1][2] = cy (principal point y = image_height / 2)
            let targetZ = 2; // default
            if (intrinsics && Array.isArray(intrinsics) && intrinsics.length >= 2) {
                const fx = intrinsics[0][0];
                const fy = intrinsics[1][1];
                const cx = intrinsics[0][2];
                const cy = intrinsics[1][2];
                const imageWidth = cx * 2;  // cx is typically image_width / 2
                const imageHeight = cy * 2; // cy is typically image_height / 2

                console.log('[GaussianViewer] Intrinsics: fx=', fx, 'fy=', fy, 'cx=', cx, 'cy=', cy);
                console.log('[GaussianViewer] Image dimensions (from intrinsics):', imageWidth, 'x', imageHeight);

                // Determine if we should lock resolution to native image size
                // We lock resolution if intrinsics are provided to ensure "WYSIWYG" with high-res output
                isResolutionLocked = true;
                
                // Get current container size for scale compensation calculation
                const containerWidth = canvas.clientWidth || 512;
                const containerHeight = canvas.clientHeight || 512;

                // Lock renderer size to NATIVE image resolution
                console.log(`[GaussianViewer] Locking resolution to native: ${imageWidth}x${imageHeight}`);
                renderer.setSize(imageWidth, imageHeight);
                
                nativeAspect = imageWidth / imageHeight;
                updateCanvasDisplaySize();

                // Use NATIVE focal length (no scaling down)
                camera.data.fx = fx;
                camera.data.fy = fy;
                baseFocalLength = fx;
                baseFocalY = fy;

                // IMPORTANT: Calculate scale compensation
                // gsplat.js renders points based on their world space size projected to screen space.
                // When we view a 2048x2048 image in a 512x512 container, we are effectively zooming out.
                // To make the points appear as "solid" as they do in the original training view,
                // we need to compensate for this difference.
                
                // Empirical observation suggests we need a stronger compensation than just the ratio.
                // If user says Scale ~14 is good when ratio is ~4 (2048/512), then compensation might be squared ratio?
                // Or maybe the points from this trainer are just naturally small.
                // Let's stick to linear ratio for now but allow a base multiplier.
                
                // For now, let's trust the ratio but maybe add a boost factor if needed.
                // User reported needing ~14x scale. If image is 2048 and container 512, ratio is 4.
                // 14 / 4 = 3.5. So maybe there's an inherent factor of 3-4 missing?
                // Actually, let's just apply the ratio logic strictly first:
                // If I render at 2048px width, a point of size 1 world unit covers X pixels.
                // If I render at 512px width, it covers X/4 pixels.
                // But visually, if I look at the 2048px image scaled down to 512px on my screen (via CSS),
                // the point covers X pixels of the *buffer*, which is X/4 pixels on *screen*.
                // Wait, if we render at high res, the points are physically "correct" size in pixels for that resolution.
                // The issue is likely that "correct" size is often too sparse for point clouds that rely on splatting overlap.
                
                // Let's use the ratio, but ensure we aren't double counting.
                gaussianScaleCompensation = imageWidth / containerWidth;
                
                // Add an extra boost because often raw splats are too small without the "dilation" effect of low-res rendering
                // When you render low-res, rasterization snaps to pixels, effectively making small points relatively larger.
                // High-res rendering loses this "free aliasing coverage".
                // Let's add a heuristic boost factor.
                // User said 14x was good. 14 / (2048/512) = 3.5.
                // Let's try boosting the compensation significantly.
                // gaussianScaleCompensation *= 3.0; // Boost factor
                
                // Actually, let's change how we calculate this.
                // If the user wants "WYSIWYG" relative to the preview size:
                // We want the point to cover the same *percentage* of the screen width.
                // PointRadius / ImageWidth = Constant.
                // If we increase ImageWidth by factor S, PointRadius must increase by factor S.
                // This is what gaussianScaleCompensation = imageWidth / containerWidth does.
                
                // However, the user reports it's still sparse. This implies the *base* size is too small.
                // Maybe the "preview" logic in other viewers implicitly boosts size?
                // Or maybe the training output relies on a specific focal length?
                
                // Let's force a minimum compensation to avoid sparsity.
                // And let's default the UI scale slider to something higher if we detect high-res?
                // No, better to fix the compensation calculation.
                
                // Let's try applying a stronger multiplier.
                // If resolution is locked, we are in "High Res Mode".
                // Let's scale up by the ratio AND a bit more.
                gaussianScaleCompensation = (imageWidth / containerWidth) * 3.0; // 3.0 is a heuristic "density boost"

                console.log('[GaussianViewer] Native resolution:', imageWidth, 'x', imageHeight);
                console.log('[GaussianViewer] Container size:', containerWidth, 'x', containerHeight);
                console.log('[GaussianViewer] Gaussian scale compensation (with 3x boost):', gaussianScaleCompensation.toFixed(2), 'x');

                // Calculate vertical FOV in radians for logging
                const fovY = 2 * Math.atan(imageHeight / (2 * fy));
                const fovYDeg = fovY * 180 / Math.PI;
                console.log('[GaussianViewer] Calculated FOV:', fovYDeg, 'degrees');

                // For SHARP, the scene is in front of the camera
                // Use focal length to estimate a reasonable target distance
                // The disparity range in metadata can help estimate scene depth
                // For now, use a simple heuristic based on typical SHARP output
                targetZ = Math.max(1, fy / imageHeight * 2);
                console.log('[GaussianViewer] Target Z distance:', targetZ);
            }

            // Determine the target position (what the camera looks at)
            // For the INITIAL view (matching original image), look STRAIGHT AHEAD along Z axis
            // NOT at the scene center - that would tilt the camera
            let targetX = 0, targetY = 0;
            let orbitZ = targetZ;  // For orbiting, use a closer point
            if (splat && splat.bounds) {
                const center = splat.bounds.center();
                const size = splat.bounds.size();

                // Use scene center Z for the view direction
                targetZ = center.z;

                // For orbit center, use distance to closest object + 50%
                // Camera is at origin, so minZ is the distance to closest point
                const minZ = center.z - size.z / 2;
                orbitZ = minZ * 1.5;  // 50% past the closest point

                console.log('[GaussianViewer] Scene center:', center.x, -center.y, center.z);
                console.log('[GaussianViewer] Closest point Z:', minZ.toFixed(1));
                console.log('[GaussianViewer] Orbit center Z:', orbitZ.toFixed(1), '(closest + 50%)');
            }

            // SHARP uses Y-down coordinate system, so flip camera Y as well
            camPosY = -camPosY;

            // For SHARP: camera is at origin, scene is at positive Z
            // The orbit controls work by having the camera orbit around a target point.
            // To get the "original image view", we set camera at the computed position
            // and look at the scene center.

            const camPos = new SPLAT.Vector3(camPosX, camPosY, camPosZ);
            // Use orbitZ for the target - closer to camera for better orbit feel
            const targetPos = new SPLAT.Vector3(targetX, targetY, orbitZ);

            // Store for reset
            initialCameraData = {
                position: camPos,
                target: targetPos,
                fx: camera.data.fx,
                fy: camera.data.fy
            };

            // Set camera position - IMPORTANT: must set camera.position, not camera.data.position
            // camera.position is used by OrbitControls
            // camera.data.position is used for rendering
            camera.position.x = camPosX;
            camera.position.y = camPosY;
            camera.position.z = camPosZ;

            // Update orbit controls to orbit around the target point
            // This recalculates the internal orbit state from current camera.position
            controls.setCameraTarget(targetPos);

            console.log('[GaussianViewer] Camera set to position:', camPosX, camPosY, camPosZ);
            console.log('[GaussianViewer] Looking at target:', targetX, targetY, targetZ);
            console.log('[GaussianViewer] This should match the original input image view');
        }

        // Load a PLY file from ArrayBuffer data
        function buildMeshSignature(filename, intrinsics) {
            const intrinsicKey = intrinsics ? JSON.stringify(intrinsics) : "none";
            return `${filename || "unknown"}::${intrinsicKey}`;
        }

        async function loadPLYFromData(arrayBuffer, filename, extrinsics, intrinsics) {
            try {
                const meshSignature = buildMeshSignature(filename, intrinsics);
                const isNewMesh = meshSignature !== lastMeshSignature;
                if (isNewMesh) {
                    initialCameraData = null;
                    baseFocalLength = null;
                    baseFocalY = null;
                    nativeImageWidth = null;
                    nativeImageHeight = null;
                    lastMeshSignature = meshSignature;
                    currentScale = 1.0;
                    if (scaleInput) {
                        scaleInput.value = 1.0;
                    }
                }

                const hasIntrinsics = Array.isArray(intrinsics) && intrinsics.length >= 2;
                if (!hasIntrinsics) {
                    // Reset lock state when native resolution is unknown
                    isResolutionLocked = false;
                } else {
                    const cx = intrinsics[0][2];
                    const cy = intrinsics[1][2];
                    nativeImageWidth = cx * 2;
                    nativeImageHeight = cy * 2;
                    isResolutionLocked = true;
                    renderer.setSize(nativeImageWidth, nativeImageHeight);
                    nativeAspect = nativeImageWidth / nativeImageHeight;
                    updateCanvasDisplaySize();
                }
                
                // Clear ALL existing objects from scene
                if (scene.objects && scene.objects.length > 0) {
                    console.log('[GaussianViewer] Clearing', scene.objects.length, 'existing objects from scene');
                    // Remove all objects (iterate backwards to avoid index issues)
                    while (scene.objects.length > 0) {
                        scene.removeObject(scene.objects[0]);
                    }
                }
                currentSplat = null;

                // Pre-calculate scale compensation from intrinsics BEFORE loading
                // This ensures gaussian scales are correct from the start
                gaussianScaleCompensation = 1.0;  // Default if no intrinsics
                if (intrinsics && Array.isArray(intrinsics) && intrinsics.length >= 2) {
                    const cx = intrinsics[0][2];
                    const imageWidth = cx * 2;
                    const containerWidth = canvas.clientWidth || 512;
                    
                    // Base compensation: Ratio of Native / Display
                    let ratio = imageWidth / containerWidth;
                    
                    // Heuristic: Add a "Density Boost" for high-res rendering.
                    // High-res rendering tends to make points look sparse because they don't overlap as much
                    // as they do in lower resolutions (due to sub-pixel vs pixel rasterization effects).
                    // We multiply by an extra factor to simulate the "fullness" of a lower-res view.
                    // Based on user feedback, a factor of ~10.0 (total) is often needed for ideal density.
                    const DENSITY_BOOST = 10.0;
                    
                    gaussianScaleCompensation = ratio * DENSITY_BOOST;
                    
                    console.log('[GaussianViewer] Pre-calculated scale compensation:', gaussianScaleCompensation.toFixed(2), 'x');
                    console.log('[GaussianViewer] Ratio:', ratio.toFixed(2), 'Density Boost:', DENSITY_BOOST);
                    console.log('[GaussianViewer] (Image:', imageWidth, 'px / Container:', containerWidth, 'px)');
                }

                console.log('[GaussianViewer] Loading from data, size:', arrayBuffer.byteLength);

                // Create a blob URL from the data
                const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
                const blobUrl = URL.createObjectURL(blob);

                // Load the PLY file from blob URL using PLYLoader
                await SPLAT.PLYLoader.LoadAsync(blobUrl, scene);

                // Clean up blob URL
                URL.revokeObjectURL(blobUrl);

                // Get the loaded splat (last object in scene)
                if (scene.objects && scene.objects.length > 0) {
                    currentSplat = scene.objects[scene.objects.length - 1];

                    // Log bounds info for debugging
                    if (currentSplat.bounds) {
                        const center = currentSplat.bounds.center();
                        const size = currentSplat.bounds.size();
                        console.log('[GaussianViewer] Scene bounds center:', center.x, center.y, center.z);
                        console.log('[GaussianViewer] Scene bounds size:', size.x, size.y, size.z);
                    }

                    // Store original scales and log statistics
                    if (currentSplat.data && currentSplat.data.scales) {
                        const scales = currentSplat.data.scales;
                        const numGaussians = scales.length / 3;
                        let minScale = Infinity, maxScale = -Infinity, sumScale = 0;

                        // Store a copy of original scales (BEFORE compensation) for dynamic adjustment
                        // The stored scales include the compensation factor so user scale=1 shows correct size
                        originalScales = new Float32Array(scales.length);
                        for (let i = 0; i < scales.length; i++) {
                            // Apply compensation: gaussians need to be larger when focal length is scaled down
                            originalScales[i] = scales[i] * gaussianScaleCompensation;
                        }
                        console.log('[GaussianViewer] Stored compensated scales (factor:', gaussianScaleCompensation.toFixed(2), 'x)');

                        // Apply compensated scales immediately
                        for (let i = 0; i < scales.length; i++) {
                            scales[i] = originalScales[i];
                        }

                        // Mark data as changed so gsplat.js re-uploads to GPU
                        currentSplat.data.changed = true;

                        for (let i = 0; i < scales.length; i++) {
                            const s = scales[i];
                            minScale = Math.min(minScale, s);
                            maxScale = Math.max(maxScale, s);
                            sumScale += s;
                        }

                        const avgScale = sumScale / scales.length;
                        console.log('[GaussianViewer] === GAUSSIAN SCALE DEBUG (after compensation) ===');
                        console.log('[GaussianViewer] Number of Gaussians:', numGaussians);
                        console.log('[GaussianViewer] Compensated scale min:', minScale.toFixed(6));
                        console.log('[GaussianViewer] Compensated scale max:', maxScale.toFixed(6));
                        console.log('[GaussianViewer] Compensated scale avg:', avgScale.toFixed(6));
                        console.log('[GaussianViewer] =================================================');
                    } else {
                        console.log('[GaussianViewer] No scales data found on splat object');
                        console.log('[GaussianViewer] Splat properties:', Object.keys(currentSplat));
                        if (currentSplat.data) {
                            console.log('[GaussianViewer] Splat.data properties:', Object.keys(currentSplat.data));
                        }
                        originalScales = null;
                    }

                    // Reapply current scale (preserve across re-runs for same mesh)
                    if (currentScale !== 1.0) {
                        updateGaussianScale(currentScale);
                    } else if (scaleInput) {
                        scaleInput.value = 1.0;
                    }
                }

                // Set camera from extrinsics and intrinsics if provided
                // Only set camera on first load (when initialCameraData doesn't exist)
                // This preserves user's manual camera adjustments between workflow executions
                if ((extrinsics || intrinsics) && !initialCameraData) {
                    setCameraFromExtrinsics(extrinsics, intrinsics, currentSplat);
                    if (controls) controls.update();
                } else if (!intrinsics && !extrinsics && !initialCameraData) {
                    camera.data.fx = DEFAULT_FOCAL_LENGTH;
                    camera.data.fy = DEFAULT_FOCAL_LENGTH;
                    baseFocalLength = camera.data.fx;
                    baseFocalY = camera.data.fy;
                }

                // Show info panel
                infoPanel.classList.remove('hidden');
                infoContent.innerHTML = `<span style="color:#6cc;">Gaussian Splat Loaded</span><br><span style="color:#888;">${filename}</span>`;

                // Notify parent
                window.parent.postMessage({
                    type: 'MESH_LOADED',
                    error: null,
                    timestamp: Date.now()
                }, '*');

                console.log('[GaussianViewer] Loaded successfully');

            } catch (err) {
                console.error('[GaussianViewer] Load error:', err);
                showError('Failed to load PLY: ' + err.message);

                window.parent.postMessage({
                    type: 'MESH_ERROR',
                    error: err.message,
                    timestamp: Date.now()
                }, '*');
            }
        }

        // Reset camera to initial position
        function resetCamera() {
            if (camera && controls) {
                if (initialCameraData) {
                    // Set camera.position (used by OrbitControls), not camera.data.position
                    const pos = initialCameraData.position;
                    camera.position.x = pos.x;
                    camera.position.y = pos.y;
                    camera.position.z = pos.z;

                    // Restore focal lengths
                    if (initialCameraData.fx) {
                        camera.data.fx = initialCameraData.fx;
                        baseFocalLength = initialCameraData.fx;
                    }
                    if (initialCameraData.fy) {
                        camera.data.fy = initialCameraData.fy;
                        baseFocalY = initialCameraData.fy;
                    }

                    // Set the target - this recalculates orbit state from current camera.position
                    if (initialCameraData.target) {
                        controls.setCameraTarget(initialCameraData.target);
                    }

                    console.log('[GaussianViewer] Reset camera to position:', pos.x, pos.y, pos.z);
                    console.log('[GaussianViewer] Reset camera target:', initialCameraData.target?.x, initialCameraData.target?.y, initialCameraData.target?.z);
                } else {
                    // Default fallback
                    camera.position.x = 0;
                    camera.position.y = 0;
                    camera.position.z = 5;
                    console.log('[GaussianViewer] Reset camera to default position (0, 0, 5)');
                }
                controls.update();
                focalScaleInput.value = 1.0;
                focalScaleValue.value = 1.0;
                applyFocalScale(1.0);
                scheduleFrameLayoutUpdate();
            }
        }

        // Helper to draw black background behind transparent canvas for screenshot
        // This solves the issue where transparent parts of the gaussian render appear weirdly when pasted
        // or viewed in tools that don't handle premultiplied alpha correctly, or simply when the
        // viewer background (CSS) was providing the black color but the canvas itself was transparent.
        function getCanvasWithBlackBackground(sourceCanvas) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = sourceCanvas.width;
            tempCanvas.height = sourceCanvas.height;
            const ctx = tempCanvas.getContext('2d');
            
            // Fill with black first
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            
            // Draw original canvas on top
            ctx.drawImage(sourceCanvas, 0, 0);
            
            return tempCanvas;
        }

        // Take screenshot directly from canvas
        // Avoiding captureStream() because it can introduce artifacts or capture inter-frame states
        // Since we are now rendering at full resolution (WYSIWYG), toDataURL is the most accurate representation
        async function takeScreenshot() {
            if (!renderer || !renderer.canvas) return;

            try {
                const canvas = renderer.canvas;
                const width = canvas.width;
                const height = canvas.height;

                // Pause the animation loop to ensure we capture a stable frame
                if (animationId) cancelAnimationFrame(animationId);

                // Force a single synchronous render to ensure the buffer is populated exactly as expected
                if (scene && camera) {
                    controls.update();
                    renderer.render(scene, camera);
                }

                console.log('[GaussianViewer] Capturing screenshot via toDataURL:', width, 'x', height);

                // Composite with black background to ensure consistency with preview
                // The preview looks black because of CSS background, but the canvas might be transparent
                const finalCanvas = getCanvasWithBlackBackground(canvas);
                const dataUrl = finalCanvas.toDataURL('image/png');

                window.parent.postMessage({
                    type: 'SCREENSHOT_V2',
                    image: dataUrl,
                    timestamp: Date.now()
                }, '*');

                resumeAnimationLoop();
                console.log('[GaussianViewer] Screenshot captured successfully');
            } catch (err) {
                console.error('[GaussianViewer] Screenshot error:', err);
                resumeAnimationLoop();
            }
        }

        function updateOutputSettings(resolution, aspectRatio) {
            if (resolution) {
                outputSettings.resolution = resolution;
            }
            if (aspectRatio && aspectRatio !== "source") {
                outputSettings.aspectRatio = aspectRatio;
            }
            updateCropFrame();
        }

        async function renderForRequest(requestId, resolution, aspectRatio) {
            if (!renderer || !renderer.canvas) {
                window.parent.postMessage({
                    type: 'RENDER_ERROR',
                    request_id: requestId,
                    error: 'renderer not ready',
                    source: 'preview_gaussian_v2',
                    timestamp: Date.now()
                }, '*');
                return;
            }

            try {
                updateOutputSettings(resolution, aspectRatio);

                if (animationId) cancelAnimationFrame(animationId);

                if (scene && camera) {
                    controls.update();
                    renderer.render(scene, camera);
                }

                const outputCanvas = createOutputCanvas() || getCanvasWithBlackBackground(renderer.canvas);
                const dataUrl = outputCanvas.toDataURL('image/png');

                window.parent.postMessage({
                    type: 'RENDER_RESULT',
                    request_id: requestId,
                    image: dataUrl,
                    source: 'preview_gaussian_v2',
                    timestamp: Date.now()
                }, '*');

                resumeAnimationLoop();
            } catch (err) {
                window.parent.postMessage({
                    type: 'RENDER_ERROR',
                    request_id: requestId,
                    error: err.message,
                    source: 'preview_gaussian_v2',
                    timestamp: Date.now()
                }, '*');
                resumeAnimationLoop();
            }
        }

        function parseAspectRatio(value, fallbackWidth, fallbackHeight) {
            if (!value || value === "source") {
                return fallbackWidth > 0 && fallbackHeight > 0 ? fallbackWidth / fallbackHeight : 1.0;
            }
            if (value.includes(":")) {
                const parts = value.split(":");
                const w = parseFloat(parts[0]);
                const h = parseFloat(parts[1]);
                if (w > 0 && h > 0) {
                    return w / h;
                }
            }
            return 1.0;
        }

        function updateCropFrame() {
            const wrapper = document.getElementById('canvasWrapper');
            const wrapperRect = wrapper.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            const rect = {
                width: canvasRect.width,
                height: canvasRect.height,
                left: canvasRect.left - wrapperRect.left,
                top: canvasRect.top - wrapperRect.top
            };
            const aspect = parseAspectRatio(outputSettings.aspectRatio, rect.width, rect.height);
            if (!aspect || rect.width <= 0 || rect.height <= 0) {
                cropFrame.style.display = 'none';
                return;
            }
            if (outputSettings.aspectRatio === "source") {
                cropFrame.style.display = 'none';
                return;
            }

            let frameWidth = rect.width;
            let frameHeight = rect.width / aspect;
            if (frameHeight > rect.height) {
                frameHeight = rect.height;
                frameWidth = rect.height * aspect;
            }

            const left = (rect.width - frameWidth) / 2;
            const top = (rect.height - frameHeight) / 2;

            cropFrame.style.display = 'block';
            cropFrame.style.left = `${rect.left + left}px`;
            cropFrame.style.top = `${rect.top + top}px`;
            cropFrame.style.width = `${frameWidth}px`;
            cropFrame.style.height = `${frameHeight}px`;
        }

        function updateCanvasDisplaySize() {
            const container = document.getElementById('viewerContainer');
            const rect = container.getBoundingClientRect();
            const aspect = nativeAspect || ((renderer?.canvas?.width || 1) / (renderer?.canvas?.height || 1));
            if (!aspect || rect.width <= 0 || rect.height <= 0) {
                return;
            }

            let displayWidth = rect.width;
            let displayHeight = rect.width / aspect;
            if (displayHeight > rect.height) {
                displayHeight = rect.height;
                displayWidth = rect.height * aspect;
            }

            canvas.style.width = `${displayWidth}px`;
            canvas.style.height = `${displayHeight}px`;
        }

        function scheduleFrameLayoutUpdate() {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    updateCanvasDisplaySize();
                    updateCropFrame();
                });
            });
        }

        function getOutputDimensions() {
            const canvas = renderer?.canvas;
            const fallbackWidth = canvas?.width || 1;
            const fallbackHeight = canvas?.height || 1;
            const aspect = parseAspectRatio(outputSettings.aspectRatio, fallbackWidth, fallbackHeight);
            const resolution = Math.max(1, parseInt(outputSettings.resolution, 10) || fallbackWidth);

            let width;
            let height;
            if (aspect >= 1.0) {
                width = resolution;
                height = Math.max(1, Math.round(resolution / aspect));
            } else {
                height = resolution;
                width = Math.max(1, Math.round(resolution * aspect));
            }
            return { width, height, aspect };
        }

        function createOutputCanvas() {
            const canvas = renderer?.canvas;
            if (!canvas) return null;

            const sourceCanvas = getCanvasWithBlackBackground(canvas);
            const { width: targetWidth, height: targetHeight, aspect: targetAspect } = getOutputDimensions();
            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = targetWidth;
            outputCanvas.height = targetHeight;

            const ctx = outputCanvas.getContext('2d');
            const sourceWidth = sourceCanvas.width;
            const sourceHeight = sourceCanvas.height;
            const sourceAspect = sourceWidth / sourceHeight;

            let sx = 0;
            let sy = 0;
            let sWidth = sourceWidth;
            let sHeight = sourceHeight;

            if (Math.abs(sourceAspect - targetAspect) > 1e-4) {
                if (sourceAspect > targetAspect) {
                    sWidth = Math.round(sourceHeight * targetAspect);
                    sx = Math.round((sourceWidth - sWidth) / 2);
                } else {
                    sHeight = Math.round(sourceWidth / targetAspect);
                    sy = Math.round((sourceHeight - sHeight) / 2);
                }
            }

            ctx.drawImage(sourceCanvas, sx, sy, sWidth, sHeight, 0, 0, targetWidth, targetHeight);
            return outputCanvas;
        }

        function getCameraTarget() {
            if (!controls) return null;
            if (typeof controls.getCameraTarget === 'function') {
                return controls.getCameraTarget();
            }
            return controls.target || controls._target || controls.cameraTarget || null;
        }

        function applyCameraState(cameraState) {
            if (!camera || !controls || !cameraState) {
                console.warn('[GaussianViewer] applyCameraState skipped - missing camera/controls/state');
                return;
            }
            console.log('[GaussianViewer] Applying camera state:', cameraState);

            const position = cameraState.position;
            const target = cameraState.target;
            const fx = cameraState.fx;
            const fy = cameraState.fy;
            const scale = cameraState.scale;

            if (fx) {
                camera.data.fx = fx;
                baseFocalLength = fx;
            }
            if (fy) {
                camera.data.fy = fy;
                baseFocalY = fy;
            }

            if (position) {
                camera.position.x = position.x ?? camera.position.x;
                camera.position.y = position.y ?? camera.position.y;
                camera.position.z = position.z ?? camera.position.z;
            }

            if (target && controls.setCameraTarget) {
                controls.setCameraTarget(target);
            }

            if (scale) {
                updateGaussianScale(scale);
            }

            controls.update();
            scheduleFrameLayoutUpdate();
            console.log('[GaussianViewer] applyCameraState complete');
        }

        // Save camera parameters to parent for render node
        function setCameraParams() {
            console.log('[GaussianViewer] ===== SET CAMERA PARAMS STARTED =====');
            
            if (!renderer || !camera || !controls) {
                console.warn('[GaussianViewer] WARNING: Cannot set camera params - required objects missing');
                console.log(`[GaussianViewer] renderer: ${!!renderer}, camera: ${!!camera}, controls: ${!!controls}`);
                return;
            }

            const target = getCameraTarget();
            const canvas = renderer.canvas;
            const imageWidth = nativeImageWidth || canvas?.width || null;
            const imageHeight = nativeImageHeight || canvas?.height || null;

            console.log('[GaussianViewer] Current camera state:');
            console.log(`  - Position: x=${camera.position.x}, y=${camera.position.y}, z=${camera.position.z}`);
            console.log(`  - Target: ${target ? `x=${target.x}, y=${target.y}, z=${target.z}` : 'null'}`);
            console.log(`  - Focal length: fx=${camera.data?.fx}, fy=${camera.data?.fy}`);
            console.log(`  - Canvas size: ${canvas?.width}x${canvas?.height}`);
            console.log(`  - Image size used: ${imageWidth}x${imageHeight}`);
            console.log(`  - Scale: ${currentScale}`);
            console.log(`  - Scale compensation: ${gaussianScaleCompensation}`);

            const cameraState = {
                position: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                },
                target: target ? { x: target.x, y: target.y, z: target.z } : null,
                fx: camera.data?.fx || null,
                fy: camera.data?.fy || null,
                image_width: imageWidth,
                image_height: imageHeight,
                scale: currentScale || 1.0,
                scale_compensation: gaussianScaleCompensation || null
            };

            console.log('[GaussianViewer] Sending camera state to parent:');
            console.log(JSON.stringify(cameraState, null, 2));

            window.parent.postMessage({
                type: 'SET_CAMERA_PARAMS',
                camera_state: cameraState,
                timestamp: Date.now()
            }, '*');

            console.log('[GaussianViewer] Message posted to parent window');
            console.log('[GaussianViewer] ===== SET CAMERA PARAMS COMPLETE =====');
            scheduleFrameLayoutUpdate();
        }

        // Gaussian scale control
        const scaleInput = document.getElementById('gaussianScaleValue');
        let currentScale = 1.0;
        let scaleUpdatePending = false;
        let lastScaleValue = 1.0;

        function updateGaussianScale(newScale) {
            newScale = Math.max(0.01, Math.min(100, parseFloat(newScale) || 1.0));
            currentScale = newScale;

            // Update input
            scaleInput.value = newScale;

            // Apply scale to current splat by modifying the underlying scale data
            // gsplat.js applies Math.exp() during PLY loading, so data.scales contains LINEAR values
            // To multiply visual size by factor f, we multiply the scale values directly
            if (currentSplat && currentSplat.data && currentSplat.data.scales && originalScales) {
                console.log('[GaussianViewer] Updating gaussian scales with factor:', newScale);

                const scales = currentSplat.data.scales;

                // Apply scale factor by multiplying (scales are in linear space)
                for (let i = 0; i < scales.length; i++) {
                    scales[i] = originalScales[i] * newScale;
                }

                // Mark data as changed to trigger GPU re-upload
                // gsplat.js checks data.changed and data.detached
                currentSplat.data.changed = true;
                currentSplat.data.detached = false;
                console.log('[GaussianViewer] Set data.changed=true, data.detached=false');

                // Get the render data (could be _renderData or renderData)
                const renderData = renderer._renderData || renderer.renderData;
                if (renderData) {
                    console.log('[GaussianViewer] Found renderData, keys:', Object.keys(renderData).join(', '));

                    // Mark the splat as dirty
                    if (renderData.markDirty) {
                        renderData.markDirty(currentSplat);
                        console.log('[GaussianViewer] Called markDirty()');
                    }

                    // Try forcing the flags directly
                    renderData.dataChanged = true;
                    console.log('[GaussianViewer] Set renderData.dataChanged = true');

                    // Check needsRebuild status
                    console.log('[GaussianViewer] renderData.needsRebuild:', renderData.needsRebuild);
                    console.log('[GaussianViewer] renderData._updating size:', renderData._updating?.size);
                    console.log('[GaussianViewer] renderData._dirty size:', renderData._dirty?.size);
                } else {
                    console.log('[GaussianViewer] No renderData found on renderer');
                    console.log('[GaussianViewer] renderer keys:', Object.keys(renderer).join(', '));
                }

                // Also dispatch change event (triggers scene to pick up changes)
                if (currentSplat.dispatchEvent && currentSplat._changeEvent) {
                    currentSplat.dispatchEvent(currentSplat._changeEvent);
                    console.log('[GaussianViewer] Dispatched change event');
                }

                // Throttled force refresh by removing and re-adding the splat to scene
                // This is a workaround for gsplat.js not supporting dynamic scale updates
                if (scene && scene.removeObject && scene.addObject) {
                    lastScaleValue = newScale;  // Always update to latest value

                    if (!scaleUpdatePending) {
                        scaleUpdatePending = true;
                        const splatToRefresh = currentSplat;  // Capture reference

                        // Delay the refresh to avoid flickering during slider drag
                        setTimeout(() => {
                            scaleUpdatePending = false;

                            // Only refresh if splat is still current
                            if (splatToRefresh === currentSplat) {
                                console.log('[GaussianViewer] Forcing refresh by re-adding splat to scene');
                                scene.removeObject(splatToRefresh);
                                scene.addObject(splatToRefresh);
                                console.log('[GaussianViewer] Splat re-added to scene');
                            } else {
                                console.log('[GaussianViewer] Skipping refresh, splat changed during delay');
                            }
                        }, 150); // 150ms debounce for smoother dragging
                    }
                }

                console.log('[GaussianViewer] Scale update complete. New scale[0]:', scales[0].toFixed(6),
                            'original[0]:', originalScales[0].toFixed(6), 'multiplier:', newScale);
            } else if (currentSplat) {
                console.log('[GaussianViewer] Cannot update scales - missing data or originalScales');
                console.log('[GaussianViewer] currentSplat.data:', !!currentSplat.data);
                console.log('[GaussianViewer] currentSplat.data.scales:', !!(currentSplat.data && currentSplat.data.scales));
                console.log('[GaussianViewer] originalScales:', !!originalScales);
            }
        }

        scaleInput.addEventListener('change', (e) => updateGaussianScale(e.target.value));

        const focalScaleInput = document.getElementById('focalScale');
        const focalScaleValue = document.getElementById('focalScaleValue');

        function applyFocalScale(value) {
            console.log('[GaussianViewer] ===== APPLYING FOCAL SCALE =====');
            console.log(`[GaussianViewer] Input value: ${value}`);
            
            const scale = Math.max(0.2, Math.min(3.0, parseFloat(value) || 1.0));
            console.log(`[GaussianViewer] Clamped scale: ${scale}`);
            
            focalScaleInput.value = scale;
            focalScaleValue.value = scale;
            
            const baseFx = baseFocalLength || camera?.data?.fx || DEFAULT_FOCAL_LENGTH;
            const baseFy = baseFocalY || camera?.data?.fy || DEFAULT_FOCAL_LENGTH;
            
            console.log(`[GaussianViewer] Base focal lengths: baseFx=${baseFx}, baseFy=${baseFy}`);
            console.log(`[GaussianViewer] Using base: baseFocalLength=${baseFocalLength}, baseFocalY=${baseFocalY}`);
            console.log(`[GaussianViewer] Fallback base: camera.data.fx=${camera?.data?.fx}, camera.data.fy=${camera?.data?.fy}`);
            console.log(`[GaussianViewer] DEFAULT_FOCAL_LENGTH=${DEFAULT_FOCAL_LENGTH}`);
            
            if (camera?.data) {
                const oldFx = camera.data.fx;
                const oldFy = camera.data.fy;
                
                camera.data.fx = baseFx * scale;
                camera.data.fy = baseFy * scale;
                
                console.log(`[GaussianViewer] Updated focal lengths:`);
                console.log(`  - Old: fx=${oldFx}, fy=${oldFy}`);
                console.log(`  - New: fx=${camera.data.fx}, fy=${camera.data.fy}`);
                console.log(`  - Scale factor: ${scale}x`);
                console.log(`  - Difference: dx=${(camera.data.fx - oldFx).toFixed(4)}, dy=${(camera.data.fy - oldFy).toFixed(4)}`);
                
                // Calculate and log new FOV
                if (renderer?.canvas) {
                    const canvasHeight = renderer.canvas.height;
                    const newFovY = 2 * Math.atan(canvasHeight / (2 * camera.data.fy));
                    const newFovYDeg = newFovY * 180 / Math.PI;
                    console.log(`  - Canvas height: ${canvasHeight}`);
                    console.log(`  - New FOV Y: ${newFovYDeg.toFixed(2)} degrees`);
                }
            } else {
                console.warn('[GaussianViewer] WARNING: camera.data not available, cannot apply focal scale');
            }
            console.log('[GaussianViewer] =====================================');
        }

        focalScaleInput.addEventListener('input', (e) => applyFocalScale(e.target.value));
        focalScaleValue.addEventListener('change', (e) => applyFocalScale(e.target.value));

        const ratioSelect = document.getElementById('ratioSelect');
        function setAspectRatio(value) {
            outputSettings.aspectRatio = value || "source";
            if (ratioSelect) {
                ratioSelect.value = outputSettings.aspectRatio;
            }
            scheduleFrameLayoutUpdate();
        }

        if (ratioSelect) {
            ratioSelect.addEventListener('change', (e) => {
                setAspectRatio(e.target.value);
            });
        }


        // Event listeners
        document.getElementById('resetCamera').addEventListener('click', resetCamera);
        document.getElementById('setCamera').addEventListener('click', setCameraParams);

        // Listen for messages from parent
        window.addEventListener('message', async (event) => {
            const { type, data, filename, extrinsics, intrinsics } = event.data;

            if (type === 'LOAD_MESH_DATA' && data) {
                console.log('[GaussianViewer] Received LOAD_MESH_DATA, size:', data.byteLength);
                console.log('[GaussianViewer] Extrinsics:', extrinsics);
                console.log('[GaussianViewer] Intrinsics:', intrinsics);
                await loadPLYFromData(data, filename || 'gaussian.ply', extrinsics, intrinsics);
                applyFocalScale(focalScaleInput.value);
                scheduleFrameLayoutUpdate();
            } else if (type === 'LOAD_MESH_DATA' && !data) {
                console.warn('[GaussianViewer] LOAD_MESH_DATA missing data buffer');
            } else if (type === 'APPLY_CAMERA_STATE' && event.data?.camera_state) {
                applyCameraState(event.data.camera_state);
            } else if (type === 'RENDER_REQUEST' && event.data?.request_id) {
                const requestId = event.data.request_id;
                const resolution = event.data.output_resolution;
                const aspectRatio = event.data.output_aspect_ratio;
                console.log('[GaussianViewer] RENDER_REQUEST:', requestId, resolution, aspectRatio);
                renderForRequest(requestId, resolution, aspectRatio);
            } else if (type === 'OUTPUT_SETTINGS') {
                const resolution = event.data?.output_resolution;
                const aspectRatio = event.data?.output_aspect_ratio;
                updateOutputSettings(resolution, aspectRatio);
                console.log('[GaussianViewer] Updated output settings:', outputSettings);
            } else if (type) {
                console.log('[GaussianViewer] Unhandled message type:', type);
            }
        });

        // Initialize on load
        initViewer();

        console.log('[GaussianViewer] Ready - waiting for LOAD_MESH message');
    </script>
</body>
</html>
